/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ExecuteMsg =
  | {
      execute_oracle: {
        names: string[];
      };
    }
  | {
      register_oracle: {
        oracle: Oracle;
      };
    }
  | {
      remove_oracle: {
        name: string;
      };
    }
  | {
      register_note: {
        note: Note;
      };
    }
  | {
      remove_note: {
        chain: string;
      };
    }
  | {
      update_ownership: Action;
    }
  | {
      callback: CallbackMessage;
    };
export type QueryRequestFor_Empty =
  | {
      bank: BankQuery;
    }
  | {
      custom: Empty;
    }
  | {
      stargate: {
        /**
         * this is the expected protobuf message type (not any), binary encoded
         */
        data: Binary;
        /**
         * this is the fully qualified service path used for routing, eg. custom/cosmos_sdk.x.bank.v1.Query/QueryBalance
         */
        path: string;
        [k: string]: unknown;
      };
    }
  | {
      ibc: IbcQuery;
    }
  | {
      wasm: WasmQuery;
    };
export type BankQuery =
  | {
      balance: {
        address: string;
        denom: string;
        [k: string]: unknown;
      };
    }
  | {
      all_balances: {
        address: string;
        [k: string]: unknown;
      };
    };
/**
 * Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
 *
 * This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
 */
export type Binary = string;
/**
 * These are queries to the various IBC modules to see the state of the contract's IBC connection. These will return errors if the contract is not "ibc enabled"
 */
export type IbcQuery =
  | {
      port_id: {
        [k: string]: unknown;
      };
    }
  | {
      list_channels: {
        port_id?: string | null;
        [k: string]: unknown;
      };
    }
  | {
      channel: {
        channel_id: string;
        port_id?: string | null;
        [k: string]: unknown;
      };
    };
export type WasmQuery =
  | {
      smart: {
        contract_addr: string;
        /**
         * msg is the json-encoded QueryMsg struct
         */
        msg: Binary;
        [k: string]: unknown;
      };
    }
  | {
      raw: {
        contract_addr: string;
        /**
         * Key is the raw key used in the contracts Storage
         */
        key: Binary;
        [k: string]: unknown;
      };
    }
  | {
      contract_info: {
        contract_addr: string;
        [k: string]: unknown;
      };
    };
export type VariableType = "uint128" | "base64" | "string";
/**
 * A human readable address.
 *
 * In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.
 *
 * This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.
 *
 * This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
 */
export type Addr = string;
/**
 * Actions that can be taken to alter the contract's ownership
 */
export type Action =
  | ("accept_ownership" | "renounce_ownership")
  | {
      transfer_ownership: {
        expiry?: Expiration | null;
        new_owner: string;
      };
    };
/**
 * Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)
 */
export type Expiration =
  | {
      at_height: number;
    }
  | {
      at_time: Timestamp;
    }
  | {
      never: {};
    };
/**
 * A point in time in nanosecond precision.
 *
 * This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.
 *
 * ## Examples
 *
 * ``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);
 *
 * let ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```
 */
export type Timestamp = Uint64;
/**
 * A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u64` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);
 *
 * let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
 */
export type Uint64 = string;
export type Callback =
  | {
      query: ResultOf_ArrayOf_BinaryOr_ErrorResponse;
    }
  | {
      execute: ResultOf_ExecutionResponseOr_String;
    }
  | {
      fatal_error: string;
    };
export type ResultOf_ArrayOf_BinaryOr_ErrorResponse =
  | {
      Ok: Binary[];
      [k: string]: unknown;
    }
  | {
      Err: ErrorResponse;
      [k: string]: unknown;
    };
export type ResultOf_ExecutionResponseOr_String =
  | {
      Ok: ExecutionResponse;
      [k: string]: unknown;
    }
  | {
      Err: string;
      [k: string]: unknown;
    };

export interface Oracle {
  chain?: string | null;
  contract: string;
  name: string;
  query: QueryRequestFor_Empty;
  schedule_interval_s: number;
  variables: VariableTemplate[];
}
/**
 * An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.
 *
 * It is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)
 */
export interface Empty {
  [k: string]: unknown;
}
export interface VariableTemplate {
  name: string;
  selector: string;
  variable_type: VariableType;
}
export interface Note {
  chain: string;
  contract?: Addr | null;
  prefix: string;
}
/**
 * Executed on the callback receiver upon message completion. When being executed, the message will be tagged with "callback":
 *
 * ```json {"callback": { "initiator": ..., "initiator_msg": ..., "result": ..., }} ```
 */
export interface CallbackMessage {
  /**
   * Initaitor on the note chain.
   */
  initiator: Addr;
  /**
   * Message sent by the initaitor. This _must_ be base64 encoded or execution will fail.
   */
  initiator_msg: Binary;
  /**
   * Data from the host chain.
   */
  result: Callback;
}
export interface ErrorResponse {
  /**
   * The error that occured executing the message.
   */
  error: string;
  /**
   * The index of the first message who's execution failed.
   */
  message_index: Uint64;
}
export interface ExecutionResponse {
  /**
   * The address on the remote chain that executed the messages.
   */
  executed_by: string;
  /**
   * Index `i` corresponds to the result of executing the `i`th message.
   */
  result: SubMsgResponse[];
}
/**
 * The information we get back from a successful sub message execution, with full Cosmos SDK events.
 */
export interface SubMsgResponse {
  data?: Binary | null;
  events: Event[];
  [k: string]: unknown;
}
/**
 * A full [*Cosmos SDK* event].
 *
 * This version uses string attributes (similar to [*Cosmos SDK* StringEvent]), which then get magically converted to bytes for Tendermint somewhere between the Rust-Go interface, JSON deserialization and the `NewEvent` call in Cosmos SDK.
 *
 * [*Cosmos SDK* event]: https://docs.cosmos.network/main/core/events.html [*Cosmos SDK* StringEvent]: https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/base/abci/v1beta1/abci.proto#L56-L70
 */
export interface Event {
  /**
   * The attributes to be included in the event.
   *
   * You can learn more about these from [*Cosmos SDK* docs].
   *
   * [*Cosmos SDK* docs]: https://docs.cosmos.network/main/core/events.html
   */
  attributes: Attribute[];
  /**
   * The event type. This is renamed to "ty" because "type" is reserved in Rust. This sucks, we know.
   */
  type: string;
  [k: string]: unknown;
}
/**
 * An key value pair that is used in the context of event attributes in logs
 */
export interface Attribute {
  key: string;
  value: string;
  [k: string]: unknown;
}
